using CLIPSNET;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using Microsoft.Speech.Recognition;
using Microsoft.Speech.Synthesis; // Добавлено для озвучки вопросов
using System.Threading.Tasks;
using System.Media;

namespace ClipsFormsExample
{
    public partial class ClipsFormsExample : Form
    {
        private CLIPSNET.Environment clips = new CLIPSNET.Environment();
        private List<string> loadedFilePaths = new List<string>();
        private Dictionary<string, double> ingredientCFValues = new Dictionary<string, double>();
        private bool isEditing = false;
        private CultureInfo invariantCulture = CultureInfo.InvariantCulture;
        private CultureInfo uiCulture = CultureInfo.CurrentUICulture;
        private bool isWaitingForResponse = false; // Флаг: ждем ли мы ответа на вопрос
        private bool isVoiceEnabled = false;
        private Microsoft.Speech.Recognition.SpeechRecognitionEngine recog;
        private Microsoft.Speech.Synthesis.SpeechSynthesizer synth; // Синтезатор речи
        private string[] basicCommands = { "да", "нет", "открыть", "дальше", "рестарт" };

        public ClipsFormsExample()
        {
            InitializeComponent();
            SetupListViews();
            InitRecognition();
            InitSynthesis();
        }

        private void InitSynthesis()
        {
            synth = new SpeechSynthesizer();
            synth.SetOutputToDefaultAudioDevice();
        }

        private void InitRecognition()
        {
            recog = new Microsoft.Speech.Recognition.SpeechRecognitionEngine(new CultureInfo("ru-RU"));
            UpdateGrammar(new List<string>());
            recog.SetInputToDefaultAudioDevice();

            recog.SpeechRecognized += async (s, e) => {
                if (!isVoiceEnabled) return;

                SystemSounds.Asterisk.Play();
                string command = e.Result.Text;
                string lowerCmd = command.ToLower();

                // 1. Если ждем ответа на вопрос
                if (isWaitingForResponse)
                {
                    if (lowerCmd == "да" || lowerCmd == "нет")
                    {
                        await Task.Delay(400);
                        // Отправляем нажатие клавиш в активное окно (MessageBox)
                        if (lowerCmd == "да")
                            SendKeys.SendWait("{ENTER}");
                        else
                            SendKeys.SendWait("{RIGHT}{ENTER}");
                    }
                    return; // В режиме вопроса игнорируем всё остальное, включая ингредиенты
                }

                // 2. Если НЕ ждем ответа — обрабатываем системные команды и ингредиенты
                switch (lowerCmd)
                {
                    case "открыть": this.Invoke(new MethodInvoker(() => openFile_Click(this, EventArgs.Empty))); return;
                    case "дальше": this.Invoke(new MethodInvoker(() => nextBtn_Click(this, EventArgs.Empty))); return;
                    case "рестарт": this.Invoke(new MethodInvoker(() => resetBtn_Click(this, EventArgs.Empty))); return;
                }

                // Обработка ингредиентов (сработает только если isWaitingForResponse == false)
                this.Invoke(new MethodInvoker(() => {
                    foreach (ListViewItem item in listView1.Items)
                    {
                        if (item.Text.Equals(command, StringComparison.OrdinalIgnoreCase))
                        {
                            item.Checked = !item.Checked;
                            break;
                        }
                    }
                }));
            };
        }

        private void UpdateGrammar(List<string> additionalWords)
        {
            Choices choices = new Choices();
            choices.Add(basicCommands);
            if (additionalWords.Count > 0) choices.Add(additionalWords.ToArray());
            GrammarBuilder gb = new GrammarBuilder { Culture = new CultureInfo("ru-RU") };
            gb.Append(choices);
            recog.UnloadAllGrammars();
            recog.LoadGrammar(new Grammar(gb));
        }

        private void SetupListViews()
        {
            listView1.View = View.Details;
            listView1.CheckBoxes = true;
            listView1.FullRowSelect = true;
            listView1.Columns.Clear();
            listView1.Columns.Add("Ингредиент / Блюдо", 250);
            listView1.Columns.Add("Уверенность (CF)", 120);

            listView2.View = View.Details;
            listView2.FullRowSelect = true;
            listView2.Columns.Clear();
            listView2.Columns.Add("Блюдо / Продукт", 200);
            listView2.Columns.Add("Уверенность (CF)", 110);
        }

        private void openFile_Click(object sender, EventArgs e)
        {
            clipsOpenFileDialog.Multiselect = true;
            if (clipsOpenFileDialog.ShowDialog() == DialogResult.OK)
            {
                loadedFilePaths.Clear();
                loadedFilePaths.AddRange(clipsOpenFileDialog.FileNames);
                codeBox.Clear();
                StringBuilder combinedContent = new StringBuilder();
                foreach (string filePath in loadedFilePaths)
                {
                    string content = File.ReadAllText(filePath, Encoding.UTF8);
                    combinedContent.AppendLine($";; --- ФАЙЛ: {Path.GetFileName(filePath)} ---");
                    combinedContent.AppendLine(CleanTextContent(content));
                    combinedContent.AppendLine();
                }
                codeBox.Text = combinedContent.ToString();
                ParseClipsFile(codeBox.Text);
                outputBox.Text = $"Загружено файлов: {loadedFilePaths.Count}.\r\nИспользуйте голос или выберите ингредиенты.\r\n";
            }
        }

        private void ParseClipsFile(string text)
        {
            listView1.Items.Clear();
            listView2.Items.Clear();
            ingredientCFValues.Clear();
            var matches = Regex.Matches(text, @"\(ingredient\s+\(name\s+""([^""]+)""\)", RegexOptions.IgnoreCase);
            var uniqueNames = new HashSet<string>();
            foreach (Match match in matches)
            {
                string name = match.Groups[1].Value;
                if (uniqueNames.Add(name))
                {
                    ingredientCFValues[name] = 1.0;
                    var lvi = new ListViewItem(name);
                    lvi.SubItems.Add("");
                    listView1.Items.Add(lvi);
                }
            }
            UpdateGrammar(uniqueNames.ToList());
        }

        private void nextBtn_Click(object sender, EventArgs e)
        {
            if (loadedFilePaths.Count == 0) return;
            Task.Run(() => {
                clips.Clear();
                var sorted = loadedFilePaths.OrderBy(p => Path.GetFileName(p).ToLower() == "basic.clp" ? 0 : 1).ToList();
                foreach (string filePath in sorted) clips.Load(filePath);
                clips.Reset();

                this.Invoke(new MethodInvoker(() => {
                    foreach (ListViewItem item in listView1.Items)
                        if (item.Checked)
                        {
                            double val = ingredientCFValues.ContainsKey(item.Text) ? ingredientCFValues[item.Text] : 1.0;
                            clips.AssertString($"(input-question (name \"{item.Text}\") (certainty {ToClipsNumberString(val)}))");
                        }
                }));

                ExecuteEngineLoop();
            });
        }

        private void ExecuteEngineLoop()
        {
            clips.Run();
            var matches = (MultifieldValue)clips.Eval("(find-all-facts ((?f ioproxy)) TRUE)");

            if (matches.Count > 0)
            {
                FactAddressValue proxy = (FactAddressValue)matches[0];
                string mode = proxy.GetSlotValue("mode").ToString();

                if (mode == "1")
                {
                    isWaitingForResponse = true; // Блокируем ингредиенты

                    string message = DecodeClipsString(((MultifieldValue)proxy.GetSlotValue("messages"))[0].ToString().Trim('"'));

                    this.Invoke(new MethodInvoker(() => {
                        outputBox.AppendText("СИСТЕМА: " + message + System.Environment.NewLine);
                        if (isVoiceEnabled) synth.SpeakAsync(message);
                    }));

                    // MessageBox блокирует поток, пока пользователь не ответит (голосом или кнопкой)
                    DialogResult res = (DialogResult)this.Invoke(new Func<DialogResult>(() =>
                        MessageBox.Show(this, message, "Вопрос", MessageBoxButtons.YesNo)));

                    isWaitingForResponse = false;

                    // Приводим к нижнему регистру здесь, чтобы упростить жизнь CLIPS
                    string clipAns = (res == DialogResult.Yes) ? "да" : "нет";

                    // Добавляем кавычки \" , чтобы в CLIPS попало (answer "да"), а не (answer да)
                    clips.AssertString($"(answer \"{clipAns}\")");

                    clips.Run();
                    ExecuteEngineLoop();
                }
                else
                {
                    this.Invoke(new MethodInvoker(() => ShowProxyLogs()));
                }
            }
        }

        private void ShowProxyLogs()
        {
            outputBox.Clear();
            outputBox.AppendText("=== ОТЧЕТ СИСТЕМЫ ===\r\n\r\n");
            var matches = (MultifieldValue)clips.Eval("(find-all-facts ((?f ioproxy)) TRUE)");
            if (matches.Count == 0) return;

            FactAddressValue proxy = (FactAddressValue)matches[0];
            MultifieldValue msgs = (MultifieldValue)proxy["messages"];
            List<string> allMessages = new List<string>();

            for (int i = 0; i < msgs.Count; i++)
            {
                allMessages.Add(DecodeClipsString(msgs[i].ToString().Trim('"')));
            }

            var processLogs = allMessages.Where(m => m.Contains("ПРОЦЕСС") || m.Contains("ДЕЙСТВИЕ")).ToList();
            var finalResults = allMessages.Where(m => m.StartsWith("ИТОГО")).ToList();

            foreach (var log in processLogs) outputBox.AppendText(log + "\r\n");
            foreach (var log in allMessages.Except(processLogs).Except(finalResults)) outputBox.AppendText(log + "\r\n");
            foreach (var log in finalResults) outputBox.AppendText("\r\n>>> " + log + "\r\n");

            UpdateResultsTable(finalResults);
        }

        private void UpdateResultsTable(List<string> finalLogs)
        {
            listView2.Items.Clear();
            foreach (string msgText in finalLogs)
            {
                var match = Regex.Match(msgText, @"ИТОГО:\s*(.+)\s*\(CF=(.+)\)");
                if (match.Success)
                {
                    string name = match.Groups[1].Value.Trim();
                    double.TryParse(match.Groups[2].Value.Replace(',', '.'), NumberStyles.Any, CultureInfo.InvariantCulture, out double cf);
                    ListViewItem item = new ListViewItem(name);
                    item.SubItems.Add(cf.ToString("F2", uiCulture));
                    if (cf >= 0.8) item.BackColor = Color.LightGreen;
                    else if (cf >= 0.5) item.BackColor = Color.LightYellow;
                    else if (cf < 0.2) item.ForeColor = Color.Gray;
                    listView2.Items.Add(item);
                }
            }
        }

        private void UpdateListViewFromAnswer(string name, double cf)
        {
            foreach (ListViewItem item in listView1.Items)
                if (item.Text == name) { item.Checked = (cf > 0); item.SubItems[1].Text = ToDisplayNumberString(cf); break; }
        }

        private void listView1_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            ListViewHitTestInfo hit = listView1.HitTest(e.Location);
            if (hit.Item != null && hit.Item.Checked && hit.SubItem == hit.Item.SubItems[1])
            {
                if (isEditing) return;
                isEditing = true;
                TextBox tb = new TextBox { Bounds = hit.SubItem.Bounds, Text = hit.SubItem.Text, BorderStyle = BorderStyle.FixedSingle };
                listView1.Controls.Add(tb); tb.Focus();
                tb.KeyDown += (s, args) => {
                    if (args.KeyCode == Keys.Enter)
                    {
                        double val = ParseNumberString(tb.Text);
                        ingredientCFValues[hit.Item.Text] = val;
                        hit.Item.SubItems[1].Text = ToDisplayNumberString(val);
                        AbortEdit(tb);
                    }
                    if (args.KeyCode == Keys.Escape) AbortEdit(tb);
                };
                tb.LostFocus += (s, args) => AbortEdit(tb);
            }
        }

        private void AbortEdit(TextBox tb) { listView1.Controls.Remove(tb); tb.Dispose(); isEditing = false; }

        private void resetBtn_Click(object sender, EventArgs e)
        {
            foreach (ListViewItem item in listView1.Items) { item.Checked = false; item.SubItems[1].Text = ""; ingredientCFValues[item.Text] = 1.0; }
            listView2.Items.Clear(); outputBox.Clear();
        }

        private void listView1_ItemCheck(object sender, ItemCheckEventArgs e)
        {
            this.BeginInvoke(new MethodInvoker(() => {
                if (e.Index < listView1.Items.Count)
                {
                    var item = listView1.Items[e.Index];
                    item.SubItems[1].Text = (e.NewValue == CheckState.Checked) ? ToDisplayNumberString(ingredientCFValues[item.Text]) : "";
                }
            }));
        }

        private void btnVoice_Click(object sender, EventArgs e)
        {
            isVoiceEnabled = !isVoiceEnabled;
            btnVoice.BackColor = isVoiceEnabled ? Color.LightGreen : SystemColors.Control;
            if (isVoiceEnabled) recog.RecognizeAsync(RecognizeMode.Multiple);
            else recog.RecognizeAsyncStop();
        }

        private void saveAsButton_Click(object sender, EventArgs e)
        {
            if (clipsSaveFileDialog.ShowDialog() == DialogResult.OK)
                File.WriteAllText(clipsSaveFileDialog.FileName, codeBox.Text, Encoding.UTF8);
        }

        private string DecodeClipsString(string t) { try { return Encoding.UTF8.GetString(Encoding.Default.GetBytes(t)); } catch { return t; } }
        private string CleanTextContent(string t) => Regex.Replace(t.TrimStart('\uFEFF'), @"[\u0000-\u0008\u000B\u000C\u000E-\u001F]", "");
        private string ToClipsNumberString(double v) => v.ToString("F6", invariantCulture);
        private string ToDisplayNumberString(double v) => v.ToString("F2", uiCulture);
        private double ParseNumberString(string t) { t = t.Trim().Replace(',', '.'); return double.TryParse(t, NumberStyles.Any, invariantCulture, out double r) ? Math.Max(-1, Math.Min(1, r)) : 1.0; }
    }
}
